def words(s,q,word):# s -- строка, в которой выделяем слова, q -- набор разделителей, возвращает первое самое длинное слово в строке s согласно набору разделителй среди слов, длинне чем word
	stat=0   #в этой переменной сохраняется длина текущего слова
	i=0  #тндекс символа в строке
	while(True):# /цикл для перебора всех символов строки
		if(s[i] in q):# если очередной символ строки является разделителем
			if(stat>len(word)):#если s[i] -- это первый разделитель после слова, сравниваем длину предыдущего слова (длина которого накоплена в stat) с длиной слова, хранящегося в word
				word=s[i-stat:i]#если выделенное слово имеет длину, ольшую, чем word, вырезаем его из s и заменяем word на это слово
			stat=0 # дляследующего слова
		else:
			stat+=1  # если находимся внутри слова (текущий символ не является разделителем), увеличиваем длину
		i+=1 #переходим к следующему имволу строки s
		if(i==len(s)): #если символ s[i-1] был последним в строке s
			if stat>len(word): #если последнее слово имее длину, большую, чем wosd
				word=s[i-stat:i]
			break#//выходим из цикла
	return word

def search(SInputFile, q):
	try:   #блок, в котором возможен выброс исключений (ошибок выполнения)
		f=open(SInputFile,"r")
		word=""
		count =False # переменная для теста на пустой файл
		for buf in f:  # перебор строк файла
			word=words(buf,q,word)    # в каждой строке нахожим слово максимальной длины, не короче, чем в предыдущих строках
			count=True
		f.close()
		return word,count # возвращаем кортеж (пару значений)
	except FileNotFoundError:  # сюда попадаем, если произошел выброс исключения при открытия файла
		return None   #в этом случае возвращаем что-то, отличное от кортежа
#	except:  ловим другие исключения, их  может быть много 		


def main():
	word,z=search("1.txt"," 3\t\n")
	if word==None:
		print("File not found")
	elif z==True:
		print('Result from file: ',word,'\nlen(word)=',len(word))
	else:
		print("File is empty")
	return 0

main() 